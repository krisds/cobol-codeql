package com.semmle.cobol.population;

import com.semmle.cobol.generator.rules.RuleSet;

import static com.semmle.cobol.generator.effects.Effects.NUMLINES;
import static com.semmle.cobol.generator.effects.Effects.all;
import static com.semmle.cobol.generator.effects.Effects.assignTo;
import static com.semmle.cobol.generator.effects.Effects.atEnd;
import static com.semmle.cobol.generator.effects.Effects.collect;
import static com.semmle.cobol.generator.effects.Effects.createTuple;
import static com.semmle.cobol.generator.effects.Effects.nestedRecordStructure;
import static com.semmle.cobol.generator.effects.Effects.on;
import static com.semmle.cobol.generator.effects.Effects.print;
import static com.semmle.cobol.generator.effects.Effects.sub;
import static com.semmle.cobol.generator.effects.Effects.setAttribute;
import static com.semmle.cobol.generator.effects.Effects.setAttributeAs;
import static com.semmle.cobol.generator.effects.Effects.setAttributeToProgramText;

import static com.semmle.cobol.generator.triggers.Triggers.child;
import static com.semmle.cobol.generator.triggers.Triggers.end;
import static com.semmle.cobol.generator.triggers.Triggers.first;
import static com.semmle.cobol.generator.triggers.Triggers.isLast;
import static com.semmle.cobol.generator.triggers.Triggers.isLastChild;
import static com.semmle.cobol.generator.triggers.Triggers.PROGRAM_TEXT;
import static com.semmle.cobol.generator.triggers.Triggers.or;
import static com.semmle.cobol.generator.triggers.Triggers.path;
import static com.semmle.cobol.generator.triggers.Triggers.start;

import koopa.core.data.markers.Start;

/**
 * This class is auto-generated by 'tools/java_rules_gen.py', from the same data
 * definition as the Cobol database schema and QL wrapper classes.
 */
public class CobolRulesFromSpec {
    public static void initialize(RuleSet rules) {
        // abbreviatedNegation ...
        rules.define("<abbreviatedNegation>", //
            all(createTuple("abbr_log_not_expr"), //
                // abbr_log_not_expr.expression <- $1
                setAttribute("expression", path("<>[1]"), rules)) //
        );

        // acceptStatement ...
        rules.define("<acceptStatement>", //
            all(createTuple("accept"), //
                // accept.on_exception <- {acceptFromMnemonic/onException|acceptScreenFormat/onException}
                setAttribute("on_exception", or(path("<acceptFromMnemonic>/<onException>"), //
                    path("<acceptScreenFormat>/<onException>")), rules), //
                // accept.not_on_exception <- {acceptFromMnemonic/notOnException|acceptScreenFormat/notOnException}
                setAttribute("not_on_exception", or(path("<acceptFromMnemonic>/<notOnException>"), //
                    path("<acceptScreenFormat>/<notOnException>")), rules), //
                // accept.on_escape <- {acceptFromMnemonic/onEscape|acceptScreenFormat/onEscape}
                setAttribute("on_escape", or(path("<acceptFromMnemonic>/<onEscape>"), //
                    path("<acceptScreenFormat>/<onEscape>")), rules), //
                // accept.not_on_escape <- {acceptFromMnemonic/notOnEscape|acceptScreenFormat/notOnEscape}
                setAttribute("not_on_escape", or(path("<acceptFromMnemonic>/<notOnEscape>"), //
                    path("<acceptScreenFormat>/<notOnEscape>")), rules), //
                // accept.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // addStatement ...
        rules.define("<addStatement>", //
            all(createTuple("add"), //
                // add.corresponding <- {corresponding}
                setAttribute("corresponding", path("<corresponding>"), rules), //
                // add.initial_operands <- {identifier}
                setAttribute("initial_operands", path("<identifier>"), rules), //
                // add.to_operands <- {to/identifier|to/qualifiedDataName}
                setAttribute("to_operands", or(path("<to>/<identifier>"), //
                    path("<to>/<qualifiedDataName>")), rules), //
                // add.giving_operands <- {giving/identifier}
                setAttribute("giving_operands", path("<giving>/<identifier>"), rules), //
                // add.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // add.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // add.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // addressOf ...
        rules.define("<addressOf>", //
            all(createTuple("address_of_register"), //
                // address_of_register.data_item <- {identifier}
                setAttribute("data_item", path("<identifier>"), rules)) //
        );

        // after ...
        rules.define("<after>", //
            all(createTuple("after"), //
                // after.operand <- {identifier[1]}
                setAttribute("operand", path("<identifier>[1]"), rules), //
                // after.until <- {until}
                setAttribute("until", path("<until>"), rules)) //
        );

        // alterStatement ...
        rules.define("<alterStatement>", //
            all(createTuple("alter"), //
                // alter.alterations <- {alterationClause}
                setAttribute("alterations", path("<alterationClause>"), rules)) //
        );

        // alterationClause ...
        rules.define("<alterationClause>", //
            all(createTuple("alteration_clause"), //
                // alteration_clause.from <- {procedureName[1]}
                setAttribute("from", path("<procedureName>[1]"), rules), //
                // alteration_clause.to <- {procedureName[2]}
                setAttribute("to", path("<procedureName>[2]"), rules)) //
        );

        // atEnd ...
        rules.define("<atEnd>", //
            all(createTuple("at_end_branch"), //
                // at_end_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // atEndOfPage ...
        rules.define("<atEndOfPage>", //
            all(createTuple("at_end_of_page_branch"), //
                // at_end_of_page_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // blockContainsClause ...
        rules.define("<blockContainsClause>", //
            all(createTuple("block_contains_clause"), //
                // block_contains_clause.minimum_size <- {integer[1]}
                setAttributeToProgramText("minimum_size", path("<integer>[1]")), //
                // block_contains_clause.maximum_size <- {integer[2]}
                setAttributeToProgramText("maximum_size", path("<integer>[2]"))) //
        );

        // callStatement ...
        rules.define("<callStatement>", //
            all(createTuple("call"), //
                // call.program_name <- {programName/$1}
                setAttribute("program_name", path("<programName>/<>[1]"), rules), //
                // call.using <- {using/$*/arg|using/copyStatement}
                setAttribute("using", or(path("<using>/<>/<arg>"), //
                    path("<using>/<copyStatement>")), rules), //
                // call.giving <- {giving/addressOf|giving/identifier}
                setAttribute("giving", or(path("<giving>/<addressOf>"), //
                    path("<giving>/<identifier>")), rules), //
                // call.on_overflow <- {onOverflow}
                setAttribute("on_overflow", path("<onOverflow>"), rules), //
                // call.on_exception <- {onException}
                setAttribute("on_exception", path("<onException>"), rules), //
                // call.not_on_exception <- {notOnException}
                setAttribute("not_on_exception", path("<notOnException>"), rules), //
                // call.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // callStatement/using/byContent/arg ...
        rules.define("<callStatement>/<using>/<byContent>/<arg>", //
            all(createTuple("call_arg_by_content"), //
                // call_arg_by_content.value <- {$1}
                setAttribute("value", path("<>[1]"), rules)) //
        );

        // callStatement/using/byReference/arg ...
        rules.define("<callStatement>/<using>/<byReference>/<arg>", //
            all(createTuple("call_arg_by_reference"), //
                // call_arg_by_reference.value <- {$1}
                setAttribute("value", path("<>[1]"), rules)) //
        );

        // callStatement/using/byValue/arg ...
        rules.define("<callStatement>/<using>/<byValue>/<arg>", //
            all(createTuple("call_arg_by_value"), //
                // call_arg_by_value.value <- {$1}
                setAttribute("value", path("<>[1]"), rules)) //
        );

        // callStatement/using/copyStatement ...
        rules.define("<callStatement>/<using>/<copyStatement>", //
            all(createTuple("call_arg_copied"), //
                // call_arg_copied.copy <- $. as copyStatement
                sub(all(rules.applyRule(Start.on("cobol", "copyStatement")), //
                    atEnd(assignTo("copy"))))) //
        );

        // execCICSStatement ...
        rules.define("<execCICSStatement>", //
            all(createTuple("cics"), //
                // cics.command <- cics::{cicsStatement/command}
                setAttributeToProgramText("command", path("<cics:cicsStatement>/<cics:command>")), //
                // cics.map <- cics::{cicsStatement/option/map/value}   as cics_option_ref
                setAttributeAs("map", path("<cics:cicsStatement>/<cics:option>/<cics:map>/<cics:value>"), rules, Start.on("cobol", "cics_option_ref")), //
                // cics.queue <- cics::{cicsStatement/option/queue/value} as cics_option_ref
                setAttributeAs("queue", path("<cics:cicsStatement>/<cics:option>/<cics:queue>/<cics:value>"), rules, Start.on("cobol", "cics_option_ref")), //
                // cics.file <- cics::{cicsStatement/option/file/value}  as cics_option_ref
                setAttributeAs("file", path("<cics:cicsStatement>/<cics:option>/<cics:file>/<cics:value>"), rules, Start.on("cobol", "cics_option_ref")), //
                // cics.resp <- cics::{cicsStatement/option/resp/value}  as cics_option_ref
                setAttributeAs("resp", path("<cics:cicsStatement>/<cics:option>/<cics:resp>/<cics:value>"), rules, Start.on("cobol", "cics_option_ref"))) //
        );

        // cics_option_ref ...
        rules.define("<cics_option_ref>", //
            all(createTuple("cics_option_reference"), //
                // cics_option_reference.value <- $.
                sub(all(collect(PROGRAM_TEXT), //
                    atEnd(assignTo("value"))))) //
        );

        // closeStatement ...
        rules.define("<closeStatement>", //
            all(createTuple("close"), //
                // close.files <- {fileName}
                setAttribute("files", path("<fileName>"), rules)) //
        );

        // communicationSection ...
        rules.define("<communicationSection>", //
            all(createTuple("communication_section"), //
                // communication_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // relationCondition ...
        rules.define("<relationCondition>", //
            all(createTuple("comparison_expr"), //
                // comparison_expr.subject <- {relationSubject/$1}
                setAttribute("subject", path("<relationSubject>/<>[1]"), rules), //
                // comparison_expr.object <- $-1
                setAttribute("object", child(isLastChild(null)), rules)) //
        );

        // computeStatement ...
        rules.define("<computeStatement>", //
            all(createTuple("compute"), //
                // compute.result_operands <- {qualifiedDataName}
                setAttribute("result_operands", path("<qualifiedDataName>"), rules), //
                // compute.expr <- {arithmeticExpression}
                setAttribute("expr", path("<arithmeticExpression>"), rules), //
                // compute.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // compute.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // compute.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // conditionNameCondition ...
        rules.define("<conditionNameCondition>", //
            all(createTuple("condition_name_condition_expr"), //
                // condition_name_condition_expr.name <- {conditionName/identifier}
                setAttribute("name", path("<conditionName>/<identifier>"), rules)) //
        );

        // configurationSection ...
        rules.define("<configurationSection>", //
            all(createTuple("configuration_section"), //
                // configuration_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // configuration_section.special_names <- {specialNamesParagraph}
                setAttribute("special_names", path("<specialNamesParagraph>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // constantEntry ...
        rules.define("<constantEntry>", //
            all(createTuple("constant_entry"), //
                // constant_entry.name <- {entryName}
                setAttributeToProgramText("name", path("<entryName>")), //
                // constant_entry.level_number <- {levelNumber}
                setAttributeToProgramText("level_number", path("<levelNumber>"))) //
        );

        // continueStatement ...
        rules.define("<continueStatement>", //
            createTuple("continue_stmt") //
        );

        // copyStatement ...
        rules.define("<copyStatement>", //
            all(createTuple("copy"), //
                // copy.text_name <- {textName}
                setAttributeToProgramText("text_name", path("<textName>")), //
                // copy.library_name <- {libraryName}
                setAttributeToProgramText("library_name", path("<libraryName>"))) //
        );

        // corresponding ...
        rules.define("<corresponding>", //
            all(createTuple("corresponding_clause"), //
                // corresponding_clause.identifier <- {identifier}
                setAttribute("identifier", path("<identifier>"), rules)) //
        );

        // dataAddressIdentifier ...
        rules.define("<dataAddressIdentifier>", //
            all(createTuple("data_address_identifier"), //
                // data_address_identifier.identifier <- {identifier}
                setAttribute("identifier", path("<identifier>"), rules)) //
        );

        // dataDescriptionEntry ...
        rules.define("<dataDescriptionEntry>", //
            all(createTuple("data_description_entry"), //
                // data_description_entry.name <- {entryName}
                setAttributeToProgramText("name", path("<entryName>")), //
                // data_description_entry.level_number <- {levelNumber}
                setAttributeToProgramText("level_number", path("<levelNumber>")), //
                // data_description_entry.picture <- {pictureClause}
                setAttribute("picture", path("<pictureClause>"), rules), //
                // data_description_entry.usage <- {usageClause}
                setAttribute("usage", path("<usageClause>"), rules), //
                // data_description_entry.occurs <- {occursClause}
                setAttribute("occurs", path("<occursClause>"), rules), //
                // data_description_entry.value <- {valueClause}
                setAttribute("value", path("<valueClause>"), rules), //
                // data_description_entry.sign <- {signClause}
                setAttribute("sign", path("<signClause>"), rules), //
                // data_description_entry.redefines <- {redefinesClause} as data_reference
                setAttributeAs("redefines", path("<redefinesClause>"), rules, Start.on("cobol", "data_reference"))) //
        );

        // dataDivision ...
        rules.define("<dataDivision>", //
            all(createTuple("data_division"), //
                // data_division.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // data_division.file_section <- {fileSection}
                setAttribute("file_section", path("<fileSection>"), rules), //
                // data_division.working_storage_section <- {workingStorageSection}
                setAttribute("working_storage_section", path("<workingStorageSection>"), rules), //
                // data_division.thread_local_storage_section <- {threadLocalStorageSection}
                setAttribute("thread_local_storage_section", path("<threadLocalStorageSection>"), rules), //
                // data_division.object_storage_section <- {objectStorageSection}
                setAttribute("object_storage_section", path("<objectStorageSection>"), rules), //
                // data_division.local_storage_section <- {localStorageSection}
                setAttribute("local_storage_section", path("<localStorageSection>"), rules), //
                // data_division.linkage_section <- {linkageSection}
                setAttribute("linkage_section", path("<linkageSection>"), rules), //
                // data_division.communication_section <- {communicationSection}
                setAttribute("communication_section", path("<communicationSection>"), rules), //
                // data_division.report_section <- {reportSection}
                setAttribute("report_section", path("<reportSection>"), rules), //
                // data_division.screen_section <- {screenSection}
                setAttribute("screen_section", path("<screenSection>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // data_reference ...
        rules.define("<data_reference>", //
            all(createTuple("data_reference"), //
                // data_reference.name <- {dataName}
                setAttributeToProgramText("name", path("<dataName>")), //
                // data_reference.qualifiers <- {qualifier/dataName}
                setAttributeToProgramText("qualifiers", path("<qualifier>/<dataName>"))) //
        );

        // declaratives ...
        rules.define("<declaratives>", //
            all(createTuple("declaratives"), //
                // declaratives.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // declaratives.sections <- {.//declarativeSection}
                setAttribute("sections", path("**/<declarativeSection>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // deleteStatement ...
        rules.define("<deleteStatement>", //
            all(createTuple("delete"), //
                // delete.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // delete.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // delete.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // delete.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // dependingOn ...
        rules.define("<dependingOn>", //
            createTuple("depending_on_clause") //
        );

        // displayStatement ...
        rules.define("<displayStatement>", //
            all(createTuple("display"), //
                // display.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator")), //
                // display.on_exception <- {onException}
                setAttribute("on_exception", path("<onException>"), rules), //
                // display.not_on_exception <- {notOnException}
                setAttribute("not_on_exception", path("<notOnException>"), rules)) //
        );

        // divideStatement ...
        rules.define("<divideStatement>", //
            all(createTuple("divide"), //
                // divide.initial_operand <- {identifier}
                setAttribute("initial_operand", path("<identifier>"), rules), //
                // divide.into_operands <- {into/identifier|into/qualifiedDataName}
                setAttribute("into_operands", or(path("<into>/<identifier>"), //
                    path("<into>/<qualifiedDataName>")), rules), //
                // divide.giving_operands <- {giving/identifier}
                setAttribute("giving_operands", path("<giving>/<identifier>"), rules), //
                // divide.remainder_operand <- {remainder/identifier}
                setAttribute("remainder_operand", path("<remainder>/<identifier>"), rules), //
                // divide.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // divide.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // divide.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // elseBranch ...
        rules.define("<elseBranch>", //
            all(createTuple("else_branch"), //
                // else_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // entryStatement ...
        rules.define("<entryStatement>", //
            createTuple("entry") //
        );

        // environmentDivision ...
        rules.define("<environmentDivision>", //
            all(createTuple("environment_division"), //
                // environment_division.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // environment_division.configuration_section <- {configurationSection}
                setAttribute("configuration_section", path("<configurationSection>"), rules), //
                // environment_division.io_section <- {ioSection}
                setAttribute("io_section", path("<ioSection>"), rules), //
                // environment_division.object_section <- {objectSection}
                setAttribute("object_section", path("<objectSection>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // evaluateStatement ...
        rules.define("<evaluateStatement>", //
            all(createTuple("evaluate"), //
                // evaluate.subjects <- {subject/$*}
                setAttribute("subjects", path("<subject>/<>"), rules), //
                // evaluate.branches <- {when|whenOther}
                setAttribute("branches", or(path("<when>"), //
                    path("<whenOther>")), rules), //
                // evaluate.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // exitStatement ...
        rules.define("<exitStatement>", //
            all(createTuple("exit"), //
                // exit.endpoint <- {endpoint}
                setAttributeToProgramText("endpoint", path("<endpoint>"))) //
        );

        // exit_node ...
        rules.define("<cflow:exit_node>", //
            createTuple("exit_node") //
        );

        // false ...
        rules.define("<false>", //
            createTuple("false_expr") //
        );

        // figurativeConstant ...
        rules.define("<figurativeConstant>", //
            all(createTuple("figurative_constant_expr"), //
                // figurative_constant_expr.value <- $.
                sub(all(collect(PROGRAM_TEXT), //
                    atEnd(assignTo("value"))))) //
        );

        // selectStatement ...
        rules.define("<selectStatement>", //
            all(createTuple("file_control_entry"), //
                // file_control_entry.name <- {selectClause/fileName}
                setAttributeToProgramText("name", path("<selectClause>/<fileName>")), //
                // file_control_entry.file_status <- {fileStatusClause/qualifiedDataName} as data_reference
                setAttributeAs("file_status", path("<fileStatusClause>/<qualifiedDataName>"), rules, Start.on("cobol", "data_reference"))) //
        );

        // fileControlParagraph ...
        rules.define("<fileControlParagraph>", //
            all(createTuple("file_control_paragraph"), //
                // file_control_paragraph.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // file_control_paragraph.entries <- {fileControlEntry/selectStatement}
                setAttribute("entries", path("<fileControlEntry>/<selectStatement>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // fdFileDescriptionEntry ...
        rules.define("<fdFileDescriptionEntry>", //
            all(createTuple("file_description_entry"), //
                // file_description_entry.name <- {fileName}
                setAttributeToProgramText("name", path("<fileName>")), //
                // file_description_entry.block_contains <- {blockContainsClause}
                setAttribute("block_contains", path("<blockContainsClause>"), rules)) //
        );

        // fileName ...
        rules.define("<fileName>", //
            all(createTuple("file_reference"), //
                // file_reference.name <- $.
                sub(all(collect(PROGRAM_TEXT), //
                    atEnd(assignTo("name"))))) //
        );

        // fileSection ...
        rules.define("<fileSection>", //
            all(createTuple("file_section"), //
                // file_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // file_section.entries <- nested record structure {fileDescriptionEntry/$* | recordDescriptionEntry/$*}
                nestedRecordStructure("entries", or(path("<fileDescriptionEntry>/<>"), //
                    path("<recordDescriptionEntry>/<>")), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // functionDefinition ...
        rules.define("<functionDefinition>", //
            all(createTuple("function_definition"), //
                // function_definition.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // function_definition.identification_division <- {identificationDivision}
                setAttribute("identification_division", path("<identificationDivision>"), rules), //
                // function_definition.environment_division <- {environmentDivision}
                setAttribute("environment_division", path("<environmentDivision>"), rules), //
                // function_definition.data_division <- {dataDivision}
                setAttribute("data_division", path("<dataDivision>"), rules), //
                // function_definition.procedure_division <- {procedureDivision}
                setAttribute("procedure_division", path("<procedureDivision>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // function ...
        rules.define("<function>", //
            all(createTuple("function_identifier"), //
                // function_identifier.name <- {functionName}
                setAttributeToProgramText("name", path("<functionName>")), //
                // function_identifier.arguments <- {argument}
                setAttribute("arguments", path("<argument>"), rules)) //
        );

        // goToStatement ...
        rules.define("<goToStatement>", //
            all(createTuple("go_to"), //
                // go_to.targets <- {procedureName}
                setAttribute("targets", path("<procedureName>"), rules), //
                // go_to.depending_on <- {dependingOn}
                setAttribute("depending_on", path("<dependingOn>"), rules)) //
        );

        // gobackStatement ...
        rules.define("<gobackStatement>", //
            createTuple("goback") //
        );

        // identificationDivision ...
        rules.define("<identificationDivision>", //
            all(createTuple("identification_division"), //
                // identification_division.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // identification_division.name <- {.//programName}
                setAttributeToProgramText("name", path("**/<programName>")), //
                // [NUMLINES]
                NUMLINES) //
        );

        // identifierAtom ...
        rules.define("<identifierAtom>", //
            all(createTuple("identifier_expr"), //
                // identifier_expr.identifier <- {identifier}
                setAttribute("identifier", path("<identifier>"), rules)) //
        );

        // ifStatement ...
        rules.define("<ifStatement>", //
            all(createTuple("if_then_else"), //
                // if_then_else.condition <- {condition}
                setAttribute("condition", path("<condition>"), rules), //
                // if_then_else.then <- {thenBranch}
                setAttribute("then", path("<thenBranch>"), rules), //
                // if_then_else.else <- {elseBranch}
                setAttribute("else", path("<elseBranch>"), rules), //
                // if_then_else.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // indexedBy ...
        rules.define("<indexedBy>", //
            all(createTuple("indexed_by"), //
                // indexed_by.indices <- {indexName}
                setAttributeToProgramText("indices", path("<indexName>"))) //
        );

        // invalidKey ...
        rules.define("<invalidKey>", //
            all(createTuple("invalid_key_branch"), //
                // invalid_key_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // ioSection ...
        rules.define("<ioSection>", //
            all(createTuple("io_section"), //
                // io_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // io_section.file_control_paragraph <- {fileControlParagraph}
                setAttribute("file_control_paragraph", path("<fileControlParagraph>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // linkageSection ...
        rules.define("<linkageSection>", //
            all(createTuple("linkage_section"), //
                // linkage_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // linkage_section.entries <- nested record structure {recordDescriptionEntry/$*}
                nestedRecordStructure("entries", path("<recordDescriptionEntry>/<>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // localStorageSection ...
        rules.define("<localStorageSection>", //
            all(createTuple("local_storage_section"), //
                // local_storage_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // local_storage_section.entries <- nested record structure {recordDescriptionEntry/$*}
                nestedRecordStructure("entries", path("<recordDescriptionEntry>/<>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // negation ...
        rules.define("<negation>", //
            all(createTuple("log_not_expr"), //
                // log_not_expr.expression <- $1
                setAttribute("expression", path("<>[1]"), rules)) //
        );

        // directive/mf/set ...
        rules.define("<cobol-directives:directive>/<cobol-directives:mf>/<cobol-directives:set>", //
            all(createTuple("m_f_set_statement"), //
                // m_f_set_statement.format <- {sourceformat[last()]/parameter}
                setAttributeToProgramText("format", path("<cobol-directives:sourceformat>[-1]/<cobol-directives:parameter>"))) //
        );

        // mergeStatement ...
        rules.define("<mergeStatement>", //
            all(createTuple("merge"), //
                // merge.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // merge.using <- {using/fileName}
                setAttribute("using", path("<using>/<fileName>"), rules), //
                // merge.giving <- {giving/fileName}
                setAttribute("giving", path("<giving>/<fileName>"), rules)) //
        );

        // moveStatement ...
        rules.define("<moveStatement>", //
            all(createTuple("move"), //
                // move.corresponding <- {corresponding}
                setAttribute("corresponding", path("<corresponding>"), rules), //
                // move.initial_operand <- {sending/identifier}
                setAttribute("initial_operand", path("<sending>/<identifier>"), rules), //
                // move.to_operands <- {identifier}
                setAttribute("to_operands", path("<identifier>"), rules)) //
        );

        // multiplyStatement ...
        rules.define("<multiplyStatement>", //
            all(createTuple("multiply"), //
                // multiply.initial_operand <- {identifier}
                setAttribute("initial_operand", path("<identifier>"), rules), //
                // multiply.by_operands <- {by/identifier|by/qualifiedDataName}
                setAttribute("by_operands", or(path("<by>/<identifier>"), //
                    path("<by>/<qualifiedDataName>")), rules), //
                // multiply.giving_operands <- {giving/identifier}
                setAttribute("giving_operands", path("<giving>/<identifier>"), rules), //
                // multiply.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // multiply.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // multiply.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // nextSentenceStatement ...
        rules.define("<nextSentenceStatement>", //
            createTuple("next_sentence") //
        );

        // noData ...
        rules.define("<noData>", //
            all(createTuple("no_data_branch"), //
                // no_data_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notAtEnd ...
        rules.define("<notAtEnd>", //
            all(createTuple("not_at_end_branch"), //
                // not_at_end_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notAtEndOfPage ...
        rules.define("<notAtEndOfPage>", //
            all(createTuple("not_at_end_of_page_branch"), //
                // not_at_end_of_page_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notInvalidKey ...
        rules.define("<notInvalidKey>", //
            all(createTuple("not_invalid_key_branch"), //
                // not_invalid_key_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notOnEscape ...
        rules.define("<notOnEscape>", //
            all(createTuple("not_on_escape_branch"), //
                // not_on_escape_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notOnException ...
        rules.define("<notOnException>", //
            all(createTuple("not_on_exception_branch"), //
                // not_on_exception_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notOnOverflow ...
        rules.define("<notOnOverflow>", //
            all(createTuple("not_on_overflow_branch"), //
                // not_on_overflow_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // notOnSizeError ...
        rules.define("<notOnSizeError>", //
            all(createTuple("not_on_size_error_branch"), //
                // not_on_size_error_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // numericAtom ...
        rules.define("<numericAtom>", //
            all(createTuple("numeric_expr"), //
                // numeric_expr.literal <- {numeric}
                setAttribute("literal", path("<numeric>"), rules)) //
        );

        // specialNameStatement/numericSignIs ...
        rules.define("<specialNameStatement>/<numericSignIs>", //
            all(createTuple("numeric_sign_clause"), //
                // numeric_sign_clause.position <- {leading|trailing}
                setAttributeToProgramText("position", or(path("<leading>"), //
                    path("<trailing>"))), //
                // numeric_sign_clause.separate <- {separate}
                setAttributeToProgramText("separate", path("<separate>"))) //
        );

        // objectSection ...
        rules.define("<objectSection>", //
            all(createTuple("object_section"), //
                // object_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // objectStorageSection ...
        rules.define("<objectStorageSection>", //
            all(createTuple("object_storage_section"), //
                // object_storage_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // occursClause ...
        rules.define("<occursClause>", //
            all(createTuple("occurs_clause"), //
                // occurs_clause.minimum <- {fixed/min/integer[integerLiteral]}
                setAttributeToProgramText("minimum", path("<fixed>/<min>/<integer>[<integerLiteral>]")), //
                // occurs_clause.maximum <- {fixed/max/integer[integerLiteral]}
                setAttributeToProgramText("maximum", path("<fixed>/<max>/<integer>[<integerLiteral>]")), //
                // occurs_clause.object <- {dependingOn/qualifiedDataName} as data_reference
                setAttributeAs("object", path("<dependingOn>/<qualifiedDataName>"), rules, Start.on("cobol", "data_reference")), //
                // occurs_clause.indexed_by <- {indexedBy}
                setAttribute("indexed_by", path("<indexedBy>"), rules)) //
        );

        // omitted ...
        rules.define("<omitted>", //
            createTuple("omitted") //
        );

        // onEscape ...
        rules.define("<onEscape>", //
            all(createTuple("on_escape_branch"), //
                // on_escape_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // onException ...
        rules.define("<onException>", //
            all(createTuple("on_exception_branch"), //
                // on_exception_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // onOverflow ...
        rules.define("<onOverflow>", //
            all(createTuple("on_overflow_branch"), //
                // on_overflow_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // onSizeError ...
        rules.define("<onSizeError>", //
            all(createTuple("on_size_error_branch"), //
                // on_size_error_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // openStatement ...
        rules.define("<openStatement>", //
            all(createTuple("open"), //
                // open.files <- {fileName}
                setAttribute("files", path("<fileName>"), rules)) //
        );

        // optional ...
        rules.define("<optional>", //
            createTuple("optional") //
        );

        // header ...
        rules.define("<header>", //
            createTuple("other_header") //
        );

        // other_stmt ...
        rules.define("<other_stmt>", //
            all(createTuple("other_stmt"), //
                // other_stmt.on_exception <- {onException}
                setAttribute("on_exception", path("<onException>"), rules), //
                // other_stmt.not_on_exception <- {notOnException}
                setAttribute("not_on_exception", path("<notOnException>"), rules), //
                // other_stmt.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // other_stmt.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // other_stmt.on_overflow <- {onOverflow}
                setAttribute("on_overflow", path("<onOverflow>"), rules), //
                // other_stmt.not_on_overflow <- {notOnOverflow}
                setAttribute("not_on_overflow", path("<notOnOverflow>"), rules), //
                // other_stmt.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // other_stmt.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // other_stmt.at_end <- {atEnd}
                setAttribute("at_end", path("<atEnd>"), rules), //
                // other_stmt.not_at_end <- {notAtEnd}
                setAttribute("not_at_end", path("<notAtEnd>"), rules), //
                // other_stmt.at_end_of_page <- {atEndOfPage}
                setAttribute("at_end_of_page", path("<atEndOfPage>"), rules), //
                // other_stmt.not_at_end_of_page <- {notAtEndOfPage}
                setAttribute("not_at_end_of_page", path("<notAtEndOfPage>"), rules), //
                // other_stmt.with_data <- {withData}
                setAttribute("with_data", path("<withData>"), rules), //
                // other_stmt.no_data <- {noData}
                setAttribute("no_data", path("<noData>"), rules)) //
        );

        // paragraph ...
        rules.define("<paragraph>", //
            all(createTuple("paragraph"), //
                // paragraph.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // paragraph.name <- {paragraphName}
                setAttributeToProgramText("name", path("<paragraphName>")), //
                // paragraph.sentences <- {sentence}
                setAttribute("sentences", path("<sentence>"), rules), //
                // paragraph.exit_node <- {(.//exit_node)[last()]}
                setAttribute("exit_node", isLast(Start.on("cflow", "exit_node")), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // identifier_format6 ...
        rules.define("<identifier_format6>", //
            all(createTuple("predefined_object"), //
                // predefined_object.value <- $.
                sub(all(collect(PROGRAM_TEXT), //
                    atEnd(assignTo("value"))))) //
        );

        // procedureDivision ...
        rules.define("<procedureDivision>", //
            all(createTuple("procedure_division"), //
                // procedure_division.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // procedure_division.declaratives <- {declaratives}
                setAttribute("declaratives", path("<declaratives>"), rules), //
                // procedure_division.sentences <- {sentence}
                setAttribute("sentences", path("<sentence>"), rules), //
                // procedure_division.paragraphs <- {paragraph}
                setAttribute("paragraphs", path("<paragraph>"), rules), //
                // procedure_division.sections <- {section}
                setAttribute("sections", path("<section>"), rules), //
                // procedure_division.exit_node <- {(.//exit_node)[last()]}
                setAttribute("exit_node", isLast(Start.on("cflow", "exit_node")), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // procedureDivision/header ...
        rules.define("<procedureDivision>/<header>", //
            all(createTuple("procedure_division_header"), //
                // procedure_division_header.using <- {using/$*/arg}
                setAttribute("using", path("<using>/<>/<arg>"), rules), //
                // procedure_division_header.returning <- {returning[dataName]} as qualifiedDataName
                setAttributeAs("returning", path("<returning>[<dataName>]"), rules, Start.on("cobol", "qualifiedDataName"))) //
        );

        // procedureDivision/header/using/byOutput/arg ...
        rules.define("<procedureDivision>/<header>/<using>/<byOutput>/<arg>", //
            all(createTuple("procedure_division_parameter_by_output"), //
                // procedure_division_parameter_by_output.optional <- {optional}
                setAttribute("optional", path("<optional>"), rules), //
                // procedure_division_parameter_by_output.value <- {value[dataName]} as qualifiedDataName
                setAttributeAs("value", path("<value>[<dataName>]"), rules, Start.on("cobol", "qualifiedDataName"))) //
        );

        // procedureDivision/header/using/byReference/arg ...
        rules.define("<procedureDivision>/<header>/<using>/<byReference>/<arg>", //
            all(createTuple("procedure_division_parameter_by_reference"), //
                // procedure_division_parameter_by_reference.optional <- {optional}
                setAttribute("optional", path("<optional>"), rules), //
                // procedure_division_parameter_by_reference.value <- {value[dataName]} as qualifiedDataName
                setAttributeAs("value", path("<value>[<dataName>]"), rules, Start.on("cobol", "qualifiedDataName"))) //
        );

        // procedureDivision/header/using/byValue/arg ...
        rules.define("<procedureDivision>/<header>/<using>/<byValue>/<arg>", //
            all(createTuple("procedure_division_parameter_by_value"), //
                // procedure_division_parameter_by_value.optional <- {optional}
                setAttribute("optional", path("<optional>"), rules), //
                // procedure_division_parameter_by_value.value <- {value[dataName]} as qualifiedDataName
                setAttributeAs("value", path("<value>[<dataName>]"), rules, Start.on("cobol", "qualifiedDataName"))) //
        );

        // procedureName ...
        rules.define("<procedureName>", //
            all(createTuple("procedure_reference"), //
                // procedure_reference.name <- {name}
                setAttributeToProgramText("name", path("<name>")), //
                // procedure_reference.qualification <- {sectionName}
                setAttributeToProgramText("qualification", path("<sectionName>"))) //
        );

        // programDefinition ...
        rules.define("<programDefinition>", //
            all(createTuple("program_definition"), //
                // program_definition.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // program_definition.identification_division <- {identificationDivision}
                setAttribute("identification_division", path("<identificationDivision>"), rules), //
                // program_definition.environment_division <- {environmentDivision}
                setAttribute("environment_division", path("<environmentDivision>"), rules), //
                // program_definition.data_division <- {dataDivision}
                setAttribute("data_division", path("<dataDivision>"), rules), //
                // program_definition.procedure_division <- {procedureDivision}
                setAttribute("procedure_division", path("<procedureDivision>"), rules), //
                // program_definition.source_units <- {sourceUnit/$*} default source_unit
                setAttribute("source_units", path("<sourceUnit>/<>"), rules, Start.on("cobol", "source_unit")), //
                // [HALSTEAD]
                // [NUMLINES]
                NUMLINES) //
        );

        // qualifiedDataName ...
        rules.define("<qualifiedDataName>", //
            all(createTuple("qualified_data_name_with_subscripts"), //
                // qualified_data_name_with_subscripts.reference <- $. as data_reference
                sub(all(rules.applyRule(Start.on("cobol", "data_reference")), //
                    atEnd(assignTo("reference")))), //
                // qualified_data_name_with_subscripts.subscripts <- {subscript}
                setAttribute("subscripts", path("<subscript>"), rules), //
                // qualified_data_name_with_subscripts.reference_modifier <- {../referenceModifier}
                setAttribute("reference_modifier", path("../<referenceModifier>"), rules)) //
        );

        // qualifiedLinageCounter ...
        rules.define("<qualifiedLinageCounter>", //
            all(createTuple("qualified_linage_counter"), //
                // qualified_linage_counter.qualification <- {fileName/name}
                setAttributeToProgramText("qualification", path("<fileName>/<name>"))) //
        );

        // readStatement ...
        rules.define("<readStatement>", //
            all(createTuple("read"), //
                // read.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // read.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // read.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // read.at_end <- {atEnd}
                setAttribute("at_end", path("<atEnd>"), rules), //
                // read.not_at_end <- {notAtEnd}
                setAttribute("not_at_end", path("<notAtEnd>"), rules), //
                // read.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // referenceModifier ...
        rules.define("<referenceModifier>", //
            all(createTuple("reference_modifier"), //
                // reference_modifier.start <- {arithmeticExpression[1]}
                setAttribute("start", path("<arithmeticExpression>[1]"), rules), //
                // reference_modifier.length <- {arithmeticExpression[2]}
                setAttribute("length", path("<arithmeticExpression>[2]"), rules)) //
        );

        // relativeSubscript ...
        rules.define("<relativeSubscript>", //
            all(createTuple("relative_subscript"), //
                // relative_subscript.reference <- {identifier/identifier_format2/qualifiedDataName} as data_reference
                setAttributeAs("reference", path("<identifier>/<identifier_format2>/<qualifiedDataName>"), rules, Start.on("cobol", "data_reference")), //
                // relative_subscript.modifier <- {integer}
                setAttributeToProgramText("modifier", path("<integer>"))) //
        );

        // replaceStatement ...
        rules.define("<replaceStatement>", //
            createTuple("replace") //
        );

        // reportDescriptionEntry ...
        rules.define("<reportDescriptionEntry>", //
            all(createTuple("report_description_entry"), //
                // report_description_entry.name <- {reportName}
                setAttributeToProgramText("name", path("<reportName>"))) //
        );

        // reportGroupDescriptionEntry ...
        rules.define("<reportGroupDescriptionEntry>", //
            all(createTuple("report_group_description_entry"), //
                // report_group_description_entry.name <- {dataName}
                setAttributeToProgramText("name", path("<dataName>")), //
                // report_group_description_entry.level_number <- {levelNumber}
                setAttributeToProgramText("level_number", path("<levelNumber>")), //
                // report_group_description_entry.picture <- {pictureClause}
                setAttribute("picture", path("<pictureClause>"), rules), //
                // report_group_description_entry.occurs <- {occursClause}
                setAttribute("occurs", path("<occursClause>"), rules)) //
        );

        // reportSection ...
        rules.define("<reportSection>", //
            all(createTuple("report_section"), //
                // report_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // report_section.entries <- nested record structure {reportDescriptionEntry | reportGroupDescriptionEntry}
                nestedRecordStructure("entries", or(path("<reportDescriptionEntry>"), //
                    path("<reportGroupDescriptionEntry>")), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // returnStatement ...
        rules.define("<returnStatement>", //
            all(createTuple("return_stmt"), //
                // return_stmt.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // return_stmt.at_end <- {atEnd}
                setAttribute("at_end", path("<atEnd>"), rules), //
                // return_stmt.not_at_end <- {notAtEnd}
                setAttribute("not_at_end", path("<notAtEnd>"), rules), //
                // return_stmt.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // rewriteStatement ...
        rules.define("<rewriteStatement>", //
            all(createTuple("rewrite"), //
                // rewrite.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // rewrite.record <- {recordName/identifier}
                setAttribute("record", path("<recordName>/<identifier>"), rules), //
                // rewrite.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // rewrite.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // rewrite.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // screenDescriptionEntry ...
        rules.define("<screenDescriptionEntry>", //
            all(createTuple("screen_description_entry"), //
                // screen_description_entry.name <- {screenName}
                setAttributeToProgramText("name", path("<screenName>")), //
                // screen_description_entry.level_number <- {levelNumber}
                setAttributeToProgramText("level_number", path("<levelNumber>")), //
                // screen_description_entry.picture <- {pictureClause}
                setAttribute("picture", path("<pictureClause>"), rules), //
                // screen_description_entry.usage <- {usageClause}
                setAttribute("usage", path("<usageClause>"), rules), //
                // screen_description_entry.occurs <- {occursClause}
                setAttribute("occurs", path("<occursClause>"), rules)) //
        );

        // screenSection ...
        rules.define("<screenSection>", //
            all(createTuple("screen_section"), //
                // screen_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // screen_section.entries <- nested record structure {screenDescriptionEntry}
                nestedRecordStructure("entries", path("<screenDescriptionEntry>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // searchStatement ...
        rules.define("<searchStatement>", //
            all(createTuple("search"), //
                // search.branches <- {atEnd|when}
                setAttribute("branches", or(path("<atEnd>"), //
                    path("<when>")), rules), //
                // search.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // section ...
        rules.define("<section>", //
            all(createTuple("section"), //
                // section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // section.name <- {sectionName}
                setAttributeToProgramText("name", path("<sectionName>")), //
                // section.sentences <- {sentence}
                setAttribute("sentences", path("<sentence>"), rules), //
                // section.paragraphs <- {paragraph}
                setAttribute("paragraphs", path("<paragraph>"), rules), //
                // section.exit_node <- {(.//exit_node)[last()]}
                setAttribute("exit_node", isLast(Start.on("cflow", "exit_node")), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // sentence ...
        rules.define("<sentence>", //
            all(createTuple("sentence"), //
                // sentence.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // sentence.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt")), //
                // [NUMLINES]
                NUMLINES) //
        );

        // signClause ...
        rules.define("<signClause>", //
            all(createTuple("sign_clause"), //
                // sign_clause.position <- {leading|trailing}
                setAttributeToProgramText("position", or(path("<leading>"), //
                    path("<trailing>"))), //
                // sign_clause.separate <- {separate}
                setAttributeToProgramText("separate", path("<separate>"))) //
        );

        // sortStatement ...
        rules.define("<sortStatement>", //
            all(createTuple("sort"), //
                // sort.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // sort.using <- {using/fileName}
                setAttribute("using", path("<using>/<fileName>"), rules), //
                // sort.giving <- {giving/fileName}
                setAttribute("giving", path("<giving>/<fileName>"), rules)) //
        );

        // sdFileDescriptionEntry ...
        rules.define("<sdFileDescriptionEntry>", //
            all(createTuple("sort_merge_file_description_entry"), //
                // sort_merge_file_description_entry.name <- {fileName}
                setAttributeToProgramText("name", path("<fileName>")), //
                // sort_merge_file_description_entry.block_contains <- {blockContainsClause}
                setAttribute("block_contains", path("<blockContainsClause>"), rules)) //
        );

        // directive/iso/instruction/source ...
        rules.define("<cobol-directives:directive>/<cobol-directives:iso>/<cobol-directives:instruction>/<cobol-directives:source>", //
            all(createTuple("source_format_directive"), //
                // source_format_directive.format <- {format}
                setAttributeToProgramText("format", path("<cobol-directives:format>"))) //
        );

        // source_unit ...
        rules.define("<source_unit>", //
            all(createTuple("source_unit"), //
                // source_unit.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // source_unit.source_units <- {sourceUnit/$*} default source_unit
                setAttribute("source_units", path("<sourceUnit>/<>"), rules, Start.on("cobol", "source_unit")), //
                // [NUMLINES]
                NUMLINES) //
        );

        // specialNamesParagraph ...
        rules.define("<specialNamesParagraph>", //
            all(createTuple("special_names_paragraph"), //
                // special_names_paragraph.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // special_names_paragraph.numeric_sign <- {specialNameStatement/numericSignIs}
                setAttribute("numeric_sign", path("<specialNameStatement>/<numericSignIs>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // execSQLStatement ...
        rules.define("<execSQLStatement>", //
            all(createTuple("sql"), //
                // sql.stmt <- {sqlStatement/$*} default sql_other_stmt
                setAttribute("stmt", path("<sql:sqlStatement>/<>"), rules, Start.on("sql", "sql_other_stmt"))) //
        );

        // <SQL> alterStatement ...
        rules.define("<sql:alterStatement>", //
            all(createTuple("sql_alter_stmt"), //
                // sql_alter_stmt.subject <- {subject}
                setAttributeToProgramText("subject", path("<sql:subject>"))) //
        );

        // <SQL> closeStatement ...
        rules.define("<sql:closeStatement>", //
            all(createTuple("sql_close_stmt"), //
                // sql_close_stmt.cursor <- {cursorName}
                setAttribute("cursor", path("<sql:cursorName>"), rules)) //
        );

        // <SQL> comparison ...
        rules.define("<sql:comparison>", //
            all(createTuple("sql_comparison"), //
                // sql_comparison.op <- {comparisonOp}
                setAttribute("op", path("<sql:comparisonOp>"), rules)) //
        );

        // <SQL> countAll ...
        rules.define("<sql:countAll>", //
            createTuple("sql_count_all") //
        );

        // <SQL> createStatement ...
        rules.define("<sql:createStatement>", //
            createTuple("sql_create_stmt") //
        );

        // <SQL> cursorName ...
        rules.define("<sql:cursorName>", //
            all(createTuple("sql_cursor_name"), //
                // sql_cursor_name.name <- {identifier}
                setAttributeToProgramText("name", path("<sql:identifier>")), //
                // sql_cursor_name.module <- {module}
                setAttributeToProgramText("module", path("<sql:module>"))) //
        );

        // <SQL> declareCursorStatement ...
        rules.define("<sql:declareCursorStatement>", //
            all(createTuple("sql_declare_cursor_stmt"), //
                // sql_declare_cursor_stmt.cursor <- {cursorName}
                setAttribute("cursor", path("<sql:cursorName>"), rules)) //
        );

        // <SQL> deleteStatement ...
        rules.define("<sql:deleteStatement>", //
            all(createTuple("sql_delete_stmt"), //
                // sql_delete_stmt.table_name <- {targetTable/tableName}
                setAttribute("table_name", path("<sql:targetTable>/<sql:tableName>"), rules)) //
        );

        // <SQL> dropStatement ...
        rules.define("<sql:dropStatement>", //
            createTuple("sql_drop_stmt") //
        );

        // <SQL> equalsOp ...
        rules.define("<sql:equalsOp>", //
            createTuple("sql_eq_op") //
        );

        // <SQL> from ...
        rules.define("<sql:from>", //
            all(createTuple("sql_from_clause"), //
                // sql_from_clause.targets <- {tableReferenceList/tableReference/$*} default unknown_ref
                setAttribute("targets", path("<sql:tableReferenceList>/<sql:tableReference>/<>"), rules, Start.on("cobol", "unknown_ref"))) //
        );

        // <SQL> greaterThanOrEqualsOp ...
        rules.define("<sql:greaterThanOrEqualsOp>", //
            createTuple("sql_g_e_op") //
        );

        // <SQL> greaterThanOp ...
        rules.define("<sql:greaterThanOp>", //
            createTuple("sql_g_t_op") //
        );

        // <SQL> hostParameterName ...
        rules.define("<sql:hostParameterName>", //
            all(createTuple("sql_host_parameter_name"), //
                // sql_host_parameter_name.name <- {identifier}
                setAttributeToProgramText("name", path("<sql:identifier>"))) //
        );

        // <SQL> hostParameterSpecification ...
        rules.define("<sql:hostParameterSpecification>", //
            all(createTuple("sql_host_parameter_specification"), //
                // sql_host_parameter_specification.parameter <- {hostParameterName}
                setAttribute("parameter", path("<sql:hostParameterName>"), rules), //
                // sql_host_parameter_specification.indicator <- {indicator/hostParameterName}
                setAttribute("indicator", path("<sql:indicator>/<sql:hostParameterName>"), rules)) //
        );

        // <SQL> into ...
        rules.define("<sql:into>", //
            all(createTuple("sql_into_clause"), //
                // sql_into_clause.targets <- {$*} default unknown_spec
                setAttribute("targets", path("<>"), rules, Start.on("cobol", "unknown_spec"))) //
        );

        // <SQL> lessThanOrEqualsOp ...
        rules.define("<sql:lessThanOrEqualsOp>", //
            createTuple("sql_l_e_op") //
        );

        // <SQL> lessThanOp ...
        rules.define("<sql:lessThanOp>", //
            createTuple("sql_l_t_op") //
        );

        // <SQL> likePredicate ...
        rules.define("<sql:likePredicate>", //
            all(createTuple("sql_like_predicate"), //
                // sql_like_predicate.pattern <- {pattern/stringLiteral}
                setAttributeToProgramText("pattern", path("<sql:pattern>/<sql:stringLiteral>"))) //
        );

        // <SQL> lockTableStatement ...
        rules.define("<sql:lockTableStatement>", //
            all(createTuple("sql_lock_table_stmt"), //
                // sql_lock_table_stmt.table_name <- {tableName}
                setAttribute("table_name", path("<sql:tableName>"), rules)) //
        );

        // <SQL> notEqualsOp ...
        rules.define("<sql:notEqualsOp>", //
            createTuple("sql_n_eq_op") //
        );

        // <SQL> negation ...
        rules.define("<sql:negation>", //
            all(createTuple("sql_not_expr"), //
                // sql_not_expr.expression <- {term}
                setAttribute("expression", path("<sql:term>"), rules)) //
        );

        // <SQL> openStatement ...
        rules.define("<sql:openStatement>", //
            all(createTuple("sql_open_stmt"), //
                // sql_open_stmt.cursor <- {cursorName}
                setAttribute("cursor", path("<sql:cursorName>"), rules)) //
        );

        // <SQL> sql_other_stmt ...
        rules.define("<sql:sql_other_stmt>", //
            createTuple("sql_other_stmt") //
        );

        // <SQL> renameStatement ...
        rules.define("<sql:renameStatement>", //
            createTuple("sql_rename_stmt") //
        );

        // <SQL> selectStatement ...
        rules.define("<sql:selectStatement>", //
            all(createTuple("sql_select_stmt"), //
                // sql_select_stmt.selection <- {selectList/$*} default unknown_expr
                setAttribute("selection", path("<sql:selectList>/<>"), rules, Start.on("cobol", "unknown_expr")), //
                // sql_select_stmt.into <- {into}
                setAttribute("into", path("<sql:into>"), rules), //
                // sql_select_stmt.from <- {from}
                setAttribute("from", path("<sql:from>"), rules), //
                // sql_select_stmt.where <- {where}
                setAttribute("where", path("<sql:where>"), rules)) //
        );

        // <SQL> tableName ...
        rules.define("<sql:tableName>", //
            all(createTuple("sql_table_name"), //
                // sql_table_name.name <- {identifier}
                setAttributeToProgramText("name", path("<sql:identifier>")), //
                // sql_table_name.schema <- {schemaName}
                setAttributeToProgramText("schema", path("<sql:schemaName>")), //
                // sql_table_name.module <- {module}
                setAttributeToProgramText("module", path("<sql:module>")), //
                // sql_table_name.catalog <- {catalogName}
                setAttributeToProgramText("catalog", path("<sql:catalogName>"))) //
        );

        // <SQL> unknown_expr ...
        rules.define("<sql:unknown_expr>", //
            createTuple("sql_unknown_expr") //
        );

        // <SQL> unknown_ref ...
        rules.define("<sql:unknown_ref>", //
            createTuple("sql_unknown_reference") //
        );

        // <SQL> unknown_spec ...
        rules.define("<sql:unknown_spec>", //
            createTuple("sql_unknown_spec") //
        );

        // <SQL> updateStatement ...
        rules.define("<sql:updateStatement>", //
            all(createTuple("sql_update_stmt"), //
                // sql_update_stmt.where <- {where}
                setAttribute("where", path("<sql:where>"), rules)) //
        );

        // <SQL> where ...
        rules.define("<sql:where>", //
            all(createTuple("sql_where_clause"), //
                // sql_where_clause.search_condition <- {searchCondition}
                setAttribute("search_condition", path("<sql:searchCondition>"), rules)) //
        );

        // startStatement ...
        rules.define("<startStatement>", //
            all(createTuple("start"), //
                // start.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // start.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // start.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // start.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // stopStatement ...
        rules.define("<stopStatement>", //
            all(createTuple("stop"), //
                // stop.endpoint <- {endpoint}
                setAttributeToProgramText("endpoint", path("<endpoint>")), //
                // stop.literal <- {literal}
                setAttributeToProgramText("literal", path("<literal>"))) //
        );

        // stringStatement ...
        rules.define("<stringStatement>", //
            all(createTuple("string_stmt"), //
                // string_stmt.on_overflow <- {onOverflow}
                setAttribute("on_overflow", path("<onOverflow>"), rules), //
                // string_stmt.not_on_overflow <- {notOnOverflow}
                setAttribute("not_on_overflow", path("<notOnOverflow>"), rules), //
                // string_stmt.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // subtractStatement ...
        rules.define("<subtractStatement>", //
            all(createTuple("subtract"), //
                // subtract.corresponding <- {corresponding}
                setAttribute("corresponding", path("<corresponding>"), rules), //
                // subtract.initial_operands <- {identifier}
                setAttribute("initial_operands", path("<identifier>"), rules), //
                // subtract.from_operands <- {from/identifier}
                setAttribute("from_operands", path("<from>/<identifier>"), rules), //
                // subtract.giving_operands <- {giving/identifier}
                setAttribute("giving_operands", path("<giving>/<identifier>"), rules), //
                // subtract.on_size_error <- {onSizeError}
                setAttribute("on_size_error", path("<onSizeError>"), rules), //
                // subtract.not_on_size_error <- {notOnSizeError}
                setAttribute("not_on_size_error", path("<notOnSizeError>"), rules), //
                // subtract.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // thenBranch ...
        rules.define("<thenBranch>", //
            all(createTuple("then_branch"), //
                // then_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // threadLocalStorageSection ...
        rules.define("<threadLocalStorageSection>", //
            all(createTuple("thread_local_storage_section"), //
                // thread_local_storage_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // thread_local_storage_section.entries <- nested record structure {recordDescriptionEntry/$*}
                nestedRecordStructure("entries", path("<recordDescriptionEntry>/<>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // times ...
        rules.define("<times>", //
            createTuple("times") //
        );

        // true ...
        rules.define("<true>", //
            createTuple("true_expr") //
        );

        // unstringStatement ...
        rules.define("<unstringStatement>", //
            all(createTuple("unstring"), //
                // unstring.on_overflow <- {onOverflow}
                setAttribute("on_overflow", path("<onOverflow>"), rules), //
                // unstring.not_on_overflow <- {notOnOverflow}
                setAttribute("not_on_overflow", path("<notOnOverflow>"), rules), //
                // unstring.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // until ...
        rules.define("<until>", //
            all(createTuple("until"), //
                // until.condition <- {condition}
                setAttribute("condition", path("<condition>"), rules)) //
        );

        // usageClause ...
        rules.define("<usageClause>", //
            all(createTuple("usage_clause"), //
                // usage_clause.operand <- {usageOperand}
                setAttributeToProgramText("operand", path("<usageOperand>"))) //
        );

        // useStatement ...
        rules.define("<useStatement>", //
            createTuple("use") //
        );

        // valueClause ...
        rules.define("<valueClause>", //
            all(createTuple("value_clause"), //
                // value_clause.literal <- {literal[1]}
                setAttribute("literal", path("<literal>[1]"), rules), //
                // value_clause.through <- {literal[2]}
                setAttribute("through", path("<literal>[2]"), rules)) //
        );

        // varying ...
        rules.define("<varying>", //
            all(createTuple("varying"), //
                // varying.operand <- {identifier[1]}
                setAttribute("operand", path("<identifier>[1]"), rules), //
                // varying.until <- {until}
                setAttribute("until", path("<until>"), rules), //
                // varying.after_list <- {after}
                setAttribute("after_list", path("<after>"), rules)) //
        );

        // when ...
        rules.define("<when>", //
            all(createTuple("when_branch"), //
                // when_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt")), //
                // when_branch.objects <- {object/$*}
                setAttribute("objects", path("<object>/<>"), rules)) //
        );

        // whenOther ...
        rules.define("<whenOther>", //
            all(createTuple("when_other_branch"), //
                // when_other_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // withData ...
        rules.define("<withData>", //
            all(createTuple("with_data_branch"), //
                // with_data_branch.statements <- {statement|nestedStatements/statement|compilerStatement} default other_stmt
                setAttribute("statements", or(path("<statement>"), //
                    path("<nestedStatements>/<statement>"), //
                    path("<compilerStatement>")), rules, Start.on("cobol", "other_stmt"))) //
        );

        // workingStorageSection ...
        rules.define("<workingStorageSection>", //
            all(createTuple("working_storage_section"), //
                // working_storage_section.header <- {header}
                setAttribute("header", path("<header>"), rules), //
                // working_storage_section.entries <- nested record structure {recordDescriptionEntry/$*}
                nestedRecordStructure("entries", path("<recordDescriptionEntry>/<>"), rules), //
                // [NUMLINES]
                NUMLINES) //
        );

        // writeStatement ...
        rules.define("<writeStatement>", //
            all(createTuple("write"), //
                // write.file <- {fileName}
                setAttribute("file", path("<fileName>"), rules), //
                // write.record <- {recordName/identifier}
                setAttribute("record", path("<recordName>/<identifier>"), rules), //
                // write.invalid_key <- {invalidKey}
                setAttribute("invalid_key", path("<invalidKey>"), rules), //
                // write.not_invalid_key <- {notInvalidKey}
                setAttribute("not_invalid_key", path("<notInvalidKey>"), rules), //
                // write.at_end <- {atEnd}
                setAttribute("at_end", path("<atEnd>"), rules), //
                // write.not_at_end <- {notAtEnd}
                setAttribute("not_at_end", path("<notAtEnd>"), rules), //
                // write.at_end_of_page <- {atEndOfPage}
                setAttribute("at_end_of_page", path("<atEndOfPage>"), rules), //
                // write.not_at_end_of_page <- {notAtEndOfPage}
                setAttribute("not_at_end_of_page", path("<notAtEndOfPage>"), rules), //
                // write.scope_terminator <- {end} as scope_terminator
                setAttributeAs("scope_terminator", path("<end>"), rules, Start.on("cobol", "scope_terminator"))) //
        );

        // zeroAtom ...
        rules.define("<zeroAtom>", //
            createTuple("zero_expr") //
        );

    }
}
