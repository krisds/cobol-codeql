package com.semmle.cobol.generator.engine;

import static com.semmle.cobol.generator.events.Event.Type.END;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.semmle.cobol.generator.effects.Effect;
import com.semmle.cobol.generator.events.Event;
import com.semmle.cobol.generator.events.Event.Type;
import com.semmle.cobol.generator.events.Events;
import com.semmle.cobol.generator.events.TreePath.Node;
import com.semmle.cobol.generator.preconditions.Precondition;
import com.semmle.cobol.generator.preconditions.Preconditions;
import com.semmle.cobol.generator.triggers.Trigger;
import com.semmle.cobol.generator.triggers.TriggerDefinition;
import com.semmle.cobol.generator.triggers.TriggerState;
import com.semmle.cobol.mapping.runtime.TrapFile;

import koopa.core.data.Data;
import koopa.core.targets.Target;

/**
 * The rule engine takes {@linkplain Event}s generated by the data stream,
 * matches those events against {@linkplain Trigger}s, and runs any
 * {@linkplain Effect}s associated with triggers which activate.
 */
public class RuleEngine implements Target {

	private static final Logger LOGGER = LoggerFactory
			.getLogger(RuleEngine.class);

	private final TrapFile trapFile;

	/**
	 * The {@link Events} takes the data stream, and turns that into
	 * {@link Event} callbacks which the rule engine will subscribe to.
	 */
	private final Events events;

	/**
	 * This tracks the current/latest event being processed.
	 */
	private Event event = null;

	/**
	 * All trigger tests are reactive, which means they must be able to know
	 * whether they activate or not by looking at the latest event, and possibly
	 * with knowledge of some that went before. There are cases, however, where
	 * some effect needs to apply at a node but only if we something specific in
	 * the future. E.g. apply a rule when we see the start of node &lt;foo&gt;
	 * but only if it has a child &lt;fee&gt;.
	 * <p>
	 * The {@link Preconditions} step can be set up with logic will resolve
	 * these checks which rely on later data, but set up the result of those
	 * tests at the moment at which it is needed, so that the triggers can
	 * always rely on the latest event, or previous ones they have seen.
	 */
	private final Preconditions preconditions;

	/**
	 * Trapping comments process the events in their own way, because it is
	 * simpler to do it that way.
	 */
	private final TrapComments comments;

	/**
	 * {@link Event}s track the nesting of nodes, and thus establish the depth
	 * of the tree as it is being processed. We need this info to help trigger
	 * rules at certain depths, and to help expire rules when they go out of
	 * scope.
	 */
	private int currentDepth = 0;

	/**
	 * The active rules, grouped by the depth at which they were activated.
	 */
	private final List<List<ActiveRule>> rules = new ArrayList<>();

	/**
	 * A list of rules which should become active on the next event. Rule
	 * activation is delayed by one event, so if the effect of a rule is to
	 * activate another one, that new rule will become active on the next event.
	 */
	private final List<ActiveRule> newRules = new LinkedList<>();

	/**
	 * A list of {@link Effect}s which need to be run at the start of the
	 * engine. That is, as soon as the engine receives its very first event.
	 */
	private final List<Effect> atStarts = new LinkedList<>();

	/**
	 * A list of {@link Effect}s, grouped by the depth at which they were added.
	 * The effects for a certain depth are run the very moment we end the
	 * subtree at that depth.
	 */
	private final List<List<Effect>> atEnds = new ArrayList<>();

	/**
	 * Same as {@link #atEnds}, except that these are run after those. Rule
	 * activation, and therefore the {@link Effect}s being run is LIFO, but
	 * sometimes an effect should run as the very last in all cases.
	 */
	private final List<List<Effect>> andFinallys = new ArrayList<>();

	public RuleEngine(TrapFile trapFile) {
		this.trapFile = trapFile;
		this.comments = new TrapComments(this);

		this.events = new Events(new Events.Callback() {
			@Override
			public void process(Event event) {
				RuleEngine.this.event = event;
				processRulesForEvent();
				RuleEngine.this.comments.process(event);
			}
		});

		this.preconditions = new Preconditions(this.events);
	}

	/**
	 * Any {@link Data} coming in is fed to the {@link #preconditions} stage,
	 * which will feed into the {@link #events} stage, which will then drive the
	 * rule engine with {@link Event} callbacks.
	 */
	@Override
	public void push(Data d) {
		preconditions.push(d);
	}

	/**
	 * When we are told the stream is done, we let the {@link #preconditions}
	 * stage know as well, which will then let the {@link #events} stage know,
	 * which will trigger whatever remaining {@link Event}s are needed.
	 */
	@Override
	public void done() {
		preconditions.done();
	}

	/**
	 * Instantiate the given {@link TriggerDefinition}, and register the
	 * {@link Trigger} instance and its associated {@link Effect} at the right
	 * depth. The new {@link ActiveRule} created for this will be placed in
	 * {@link #newRules}, and will become active on the very next event.
	 */
	public void add(TriggerDefinition def, Effect effect) {
		final int scope = def.getScope(currentDepth);
		final Trigger trigger = def.getTriggerFor(null, this);
		final ActiveRule rule = new ActiveRule(scope, trigger, effect);

		if (LOGGER.isTraceEnabled())
			LOGGER.trace("Adding " + rule);

		newRules.add(rule);
	}

	/**
	 * Add a {@link Precondition} to the {@link #preconditions} stage.
	 */
	public void addPrecondition(Precondition precondition) {
		preconditions.add(precondition);
	}

	/**
	 * Tell the rule engine to run this effect as soon as it sees its first
	 * event.
	 * <p>
	 * If this gets called after we have seen the first event this will throw an
	 * {@link IllegalStateException}.
	 */
	public void atStart(Effect atStart) {
		if (event != null)
			throw new IllegalStateException("Engine has already started.");

		atStarts.add(atStart);
	}

	/**
	 * Tell the rule engine to run this effect once the current subtree is at
	 * its end.
	 * <p>
	 * If this gets called at the moment the current subtree is at its end, the
	 * effect will be run immediately.
	 */
	public void atEnd(Effect atEnd) {
		if (atEnd == null)
			return;

		if (event != null && event.type == Type.END)
			atEnd.apply(event, null, this);
		else {
			while (atEnds.size() <= currentDepth)
				atEnds.add(new LinkedList<>());

			atEnds.get(currentDepth).add(atEnd);
		}
	}

	/**
	 * Tell the rule engine to run this effect once the subtree matching the
	 * given {@link Node} is at its end.
	 * <p>
	 * If this gets called when the subtree has already ended, the effect will
	 * be run immediately.
	 */
	public void atEndOf(Node node, Effect atEnd) {
		if (atEnd == null)
			return;

		if (node.depth > currentDepth)
			atEnd.apply(event, null, this);
		else if (node.depth == currentDepth && event.type == Type.END)
			atEnd.apply(event, null, this);
		else
			atEnds.get(node.depth).add(atEnd);
	}

	/**
	 * Same as {@link #atEnd(Effect)}, except that these will be run after any
	 * of those.
	 */
	public void andFinally(Effect andFinally) {
		if (andFinally == null)
			return;

		if (event.type == Type.END)
			andFinally.apply(event, null, this);
		else {
			while (andFinallys.size() <= currentDepth)
				andFinallys.add(new LinkedList<>());

			andFinallys.get(currentDepth).add(andFinally);
		}
	}

	/**
	 * The heart of the engine. This takes the {@link Event}, matches it against
	 * the {@link Trigger}s, and runs {@link Effect}s associated with triggers
	 * which were activated.
	 */
	private void processRulesForEvent() {
		// We always start by establishing the current depth.
		final Node node = event.getNode();
		currentDepth = node == null ? 0 : node.depth;

		if (LOGGER.isTraceEnabled())
			LOGGER.trace("> " + event);

		// This will be run only once, when we see the very first event. After
		// that the effects in the list will be cleared, and never run again.
		if (!atStarts.isEmpty()) {
			for (Effect atStart : atStarts)
				atStart.apply(event, null, this);

			atStarts.clear();
		}

		// Any new rule which were added during the previous event now get
		// sorted into their right spot.
		if (!newRules.isEmpty()) {
			for (ActiveRule newRule : newRules) {
				final int depth = newRule.getDepth();
				while (rules.size() <= depth)
					rules.add(new ArrayList<>());
				rules.get(depth).add(newRule);
			}
			newRules.clear();
		}

		if (event.type == END) {
			// Apply effects which need to be run at the end of a scope.
			if (currentDepth < atEnds.size()) {
				final List<Effect> endEffects = atEnds.get(currentDepth);
				for (Effect endEffect : endEffects) {
					if (LOGGER.isTraceEnabled())
						LOGGER.trace("At end : " + endEffect);
					endEffect.apply(event, null, this);
				}
				endEffects.clear();
			}

			// Apply effects which need to be run at the very end of a scope.
			if (currentDepth < andFinallys.size()) {
				final List<Effect> finalEffects = andFinallys.get(currentDepth);
				for (Effect finalEffect : finalEffects) {
					if (LOGGER.isTraceEnabled())
						LOGGER.trace("And finally : " + finalEffect);
					finalEffect.apply(event, null, this);
				}
				finalEffects.clear();
			}

			// Deactivate rules which have gone out of scope.
			if (currentDepth < rules.size()) {
				final List<ActiveRule> rulesOutOfScope = rules
						.get(currentDepth);
				for (ActiveRule rule : rulesOutOfScope)
					if (LOGGER.isTraceEnabled())
						LOGGER.trace("Out of scope : " + rule);
				rulesOutOfScope.clear();
			}
		}

		// We walk over all active rules, in reverse order of depth.
		// NOTE: this MUST test all matching rules, as triggers may activate
		// depending on past events !
		// NOTE: this MUST apply all triggered rules, not just the first one it
		// finds !
		for (int l = Math.min(currentDepth, rules.size() - 1); l >= 0; l--) {
			final Iterator<ActiveRule> i = rules.get(l).iterator();
			while (i.hasNext()) {
				final ActiveRule rule = i.next();
				final TriggerState a = rule.evaluate(event);

				// If the rule triggered we apply the effect.
				if (a.fired) {
					if (LOGGER.isTraceEnabled())
						LOGGER.trace(rule + " <= " + event.data);
					rule.apply(event, this);
				}

				// If the rule's trigger defined new triggers, we add those in
				// so they may be matched by the next event.
				if (a.also != null)
					for (TriggerDefinition def : a.also)
						add(def.getTriggerFor(event, this), rule.effect);

				// If a trigger expired we remove the rule from further
				// processing.
				if (a.expired) {
					if (LOGGER.isTraceEnabled())
						LOGGER.trace("Rule expired : " + rule);
					i.remove();
				}

				// Note that "triggered", "also" and "expired" can appear in any
				// combination. Look at the logic for different triggers to see
				// how and why that is used.
			}
		}
	}

	/**
	 * Get the {@link TrapFile} for which this rule engine is active.
	 */
	public TrapFile getTrapFile() {
		return trapFile;
	}
}
