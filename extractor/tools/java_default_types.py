'''Tool for generating the Java data model.'''

import io, os, re, sys

from contextlib import contextmanager
from operator import attrgetter

from AST import AstType, PrimitiveType, ClassType, UnionType, ListType
from gentools import ast_types_from_module, wordnum_sorted, get_disjunction_names, get_main_relation, get_primitive_attribute_relation, get_primitive_list_item_relation
from ASTExt import NodeType

class CodeWriter:
    '''Utility class for writing code, that maintains an indent level for strings
       submitted to it, and thus simplifies the process of outputting indented code to
       a file or stream.'''
    def __init__(self, out, indent_size=4):
        '''out         - Stream to which code shall be output
           indent_size - Number of characters by which to indent for each indentation level.'''
        self.out          = out         # Output stream
        self.indent_level = 0           # Current indentation level
        self.indent_size  = indent_size # Number of spaces per indentation level
        self.indent_next  = True        # Next input should be indented?

    def indent(self, levels=1):
        '''Increase (or decrease) the indentation level.'''
        self.indent_level += levels
        assert self.indent_level >= 0

    def dedent(self, levels=1):
        '''Decrease (or increase) the indentation level.'''
        self.indent(-levels)

    def write(self, code, indent=0):
        '''Write the given 'code' string. The string will be split by newlines, and the current
           indent prefixed (using spaces) before each line output. If the most recent write
           ended with a newline, then the first line of 'code' will be indented.
           
           code   - String of code to be written. NB: include a final newline unless the first
                    line of any subsequent write should _not_ be indented.
           indent - Optional adjustment to the current indentation level to adopt for this
                    particular write.
           '''
        self.indent(indent)
        if len(code) == 0:
            return
        # Split into lines, preserving newline characters
        lines = [ l + '\n' for l in code.split('\n') ]
        if not code[-1].endswith('\n'):
            lines[-1] = lines[-1][:-1] # Last line is not terminated, so remove appended newline
        else:
            lines = lines[:-1] # Remove empty string appended to indicate final newline
        for line in lines:
            if self.indent_next:
                if line != '\n':
                    self.out.write(('%%%ds' % (self.indent_level * self.indent_size)) % '')
                self.indent_next = False
            self.out.write(line)
            self.indent_next = len(line) > 0 and line[-1] == '\n'
        self.dedent(indent)

    @staticmethod
    @contextmanager
    def create(path, **kwargs):
        '''Open (and later close) a CodeWriter that writes to a new file at the specified path.'''
        with open(path, 'w', **kwargs) as f:
            yield CodeWriter(f)

def print_usage():
    print("Usage %s AST_FILE [OUTPUT]\n" % sys.argv[0])
    print("Generate a Java data model of the default type mappings.")
    print("AST_FILE: The Python file containing the AST definition.")
    

def write_java_default_types(out, spec):
    '''Write the code for the Java data model to the given CodeWriter.'''
    module = __import__(spec)
    gen_name = '/'.join(__file__.split(os.path.sep)[-2:])
    ast_types = wordnum_sorted(ast_types_from_module(module))

    out.write(cobol_default_types_preamble % gen_name)
    out.indent(levels=2)

    write_default_types(out, ast_types)

    out.dedent(levels=2)
    out.write(cobol_default_types_close)


def write_default_types(out, ast_types):
    for ast_type in ast_types:
        write_default_type(out, ast_type)

def write_default_type(out, ast_type):
    if not isinstance(ast_type, NodeType): return
    if not ast_type.is_case_type(): return

    type_name = ast_type.name
    node_name = ast_type.node_name
    namespace = "cobol"

    if type_name is None or node_name is None: return
    
    if type_name == "exit_node":
        namespace = "cflow"
    
    if node_name.startswith('<SQL> '):
        node_name = node_name[len('<SQL> '):]
        namespace = "sql"
    
    if node_name.find('/') >= 0: return
    
    out.write('defaultTypes.put(Start.on("%s", "%s"), "%s");\n' % (namespace, node_name, type_name))


cobol_default_types_preamble = """package com.semmle.cobol.population;

import java.util.Map;

import koopa.core.data.markers.Start;

/**
 * This class is auto-generated by '%s', from the same data
 * definition as the Cobol database schema and QL wrapper classes.
 */
public class CobolTypesFromSpec {
    public static void populateDefaultTypes(Map<Start, String> defaultTypes) {
"""

cobol_default_types_close="""    }
}
"""


def main(args):
    '''Write the code for the abstract extractor visitor.'''
    if len(args) == 3:
        with CodeWriter.create(args[2], encoding='utf-8', newline='') as out:
            write_java_default_types(out, args[1])
    elif len(args) == 2:
        out = CodeWriter(sys.stdout)
        write_java_default_types(out, args[1])
    else:
        print_usage()
        sys.exit(-1)

if __name__ == '__main__':
    main(sys.argv)
